[{"id":0,"href":"/uni/docs/","title":"Docs","section":"uni' docs","content":"uni'   A mono-repo containing code I\u0026rsquo;ve written or studied for self-education purposes.\nContents #  Currently, the contents of this mono-repo are broken down into the following top-level concerns:\n Algorithms - Code for Leetcode, mostly. Books - Code for all kinds of practical exercises in various great textbooks. Homework, practicals, exercises, labs, assignments, etc.  Computer Systems: A Programmer\u0026rsquo;s Perspective Crafting Interpreters Data Science From Scratch Functional Programming in Scala Programming Rust Structure and Interpretation of Computer Programs The Algorithm Design Manual The Rust Programming Language   Concurrency - Code written to learn how to solve concurrency problems/exercises using code. Databases - SQL, mostly. Docs - Static-site documentation for monorepo. Served at https://thundergolfer.com/uni, or viewable locally (see readme instructions within folder). Languages - Code for learning the details of programming languages (C, C++, Java, Python, Rust). Machine Learning - H Y P E Performance - Code for learning about how certain programs change in system resource usage under load. Operating Systems - Code written to learn how UNIX (Linux, macOS) operating systems actually work. Optimization - Code written to learn how to solve optimization problems using code, particularly using the kinds of optimization algorithms used in Machine Learning. third_party - Code and configuration for managing third-party code/packages in Bazel, and not of interest in of itself. Tools - Tooling code, scripts, and configuration, serving the repository\u0026rsquo;s needs and not of interest in of itself.  Setup #  Prerequisites #   Nix - Provide a hermetic developer environment. Runs properly on my machine, runs properly on everyone else\u0026rsquo;s. At least, that\u0026rsquo;s the idea. Direnv - Integrate with Nix\u0026rsquo;s nix-shell to provide hermetic developer environment. lorri Bazel - build everything fast, and correctly, no matter the language. zstd - Required during install of Bazel Python toolchain on OSX.  Importantly, the following components are included in the repo\u0026rsquo;s Nix environment specification:\n Python 3 Racket lang, used in books/sicp  Development #  Build #  bazel build //...\nTest #  bazel test //...\n"},{"id":1,"href":"/uni/docs/algorithms/","title":"Algorithms","section":"Docs","content":"Algorithms #   codeforces - Implementations for problems from codeforces.com. leetcode - Implementations for problems from leetcode.com. named - Implementations for well-known algorithms. Algorithms that are named. onlinejudge.org - \u0026lsquo;The Algorithm Design Manual\u0026rsquo; poses problems from this site.  "},{"id":2,"href":"/uni/docs/books/computer_systems_app/","title":"Computer Systems App","section":"Books","content":"Computer Systems: A Programmer\u0026rsquo;s Perspective #  I worked through this textbook as part of the teachyourselfcs.com program.\nContents #   Twelve chapter_* folders containing code the solves the \u0026lsquo;homework problems\u0026rsquo; (and sometimes \u0026lsquo;practice problems\u0026rsquo;) from the respective chapter. The labs/ folder, which contains the 9 labs provided with the CS:APP textbook.  \u0026ldquo;Test your code on multiple machines\u0026rdquo; #  Parts of the textbook (eg. chapter two) are interested in the low-level computer architectural differences between different machines, like 32-bit vs. 64-bit architectures, and little-endian vs. big-endian.\nHomework exercises and practice problems sometimes ask you to \u0026ldquo;test your code on multiple machines\u0026rdquo;, as if we\u0026rsquo;ve all got multiple computers with different architectures easily accessible.\nBelow is a table of different platform and whether I\u0026rsquo;ve figured how to easily run this repo\u0026rsquo;s code on them:\n   Platform Word Size Endian-ness How To Notes     Linux 64-bit 64 Little Use Github Codespaces The .devcontainer configures the Github Codespace automatically   Linux 32-bit 32 Little üöß Dunno yet    OSX 64-bit 64 Little I use my personal laptop, which is 64-bit by default.    Windows 64 Little üöß Dunno yet    Sun (Solaris) 64 Big Use \u0026lsquo;Oracle Solaris 11.4\u0026rsquo; Image on Oracle Public Cloud Bazel will not be useable.    "},{"id":3,"href":"/uni/docs/books/computer_systems_app/labs/architecture/","title":"Architecture","section":"Labs","content":"Architecture Lab #   üëãÔ∏è Note: Updated to Y86-64 for CS:APP3e. Students are given a small default Y86-64 array copying function and a working pipelined Y86-64 processor design that runs the copy function in some nominal number of clock cycles per array element (CPE). The students attempt to minimize the CPE by modifying both the function and the processor design. This gives the students a deep appreciation for the interactions between hardware and software.\n  Note: The lab materials include the master source distribution of the Y86-64 processor simulators and the Y86-64 Guide to Simulators. (I unzipped it into tar/)\n Contents #   Files downloaded from CS:APP website as archlab-handout.tar, and listed below in the original README contents  Lab Assignment Write-Up #  csapp.cs.cmu.edu/3e/archlab.pdf.\nThis write-up is pretty helpful for even those doing self-study. Read through it to learn how to approach this lab\u0026rsquo;s problem.\nOriginal README.md #  This section is copied from csapp.cs.cmu.edu/3e/README-archlab. It was modified only to conform to standard Markdown formatting.\nIt is not particularly useful for people doing self-study, but is reproduced here anyway.\n ##################################################################### # CS:APP Architecture Lab # Directions to Instructors # # Copyright (c) 2002, 2011, 2015 R. Bryant and D. O'Hallaron, # All rights reserved. May not be used, modified, or copied without permission. # ###################################################################### This directory contains the files that you will need to run the CS:APP architecture lab, which develops a student\u0026rsquo;s understanding of processor design and the close relationship between software and hardware.\n1. Overview #  In this lab, students learn about the design and implementation of a pipelined Y86-64 processor, optimizing its performance on a benchmark Y86-64 array copy program called ncopy.ys. Students are allowed to make any semantics preserving transformations to the benchmark program, or to make enhancements to the pipelined processor, or both. The goal is to minimize the number of clock cycles per array element (CPE).\n2. Files #   Makefile\tMakefile that builds the Lab README\tThis file archlab-handout/\tThe files handed out to the students grade/\tAutograding scripts simguide/\tCS:APP Guide to Simulators document src/\tMaster distribution of the Y86-64 tools sim/\tStudent distribution of the Y86-64 tools (subset of src) writeup/\tThe architecture lab writeup  3. Building the Lab #  Step 1: Build the \u0026ldquo;master distribution\u0026rdquo; of the Y86-64 tools in directory ./src on your system. The master distribution is the instructor\u0026rsquo;s version of the tools that contains the solution files for the lab. See ./src/README for instructions on how to build the master distribution. The process involves setting three variables in ./src/Makefile and then typing \u0026ldquo;make\u0026rdquo;. The default values are for Linux.\nStep 2. Modify ./src/Makefile-sim with the same three variable assignments that you used in ./src/Makefile. The Makefile-sim file is the Makefile that the students will use their in their personal student distributions of the Y86-64 tools. The student distribution is a subset of the master distribution, minus the solution files and a master set of HCL files.\nStep 3. Modify ./src/Makefile-handout with the default team name (TEAM), default handin version number (VERSION), and the directories where the three parts should be copied to when they are handed in (HANDINDIR-PART{A,B,C}). The Makefile-handout file is the the Makefile that the students receive in the archlab-handout/. They use it to hand in their solutions.\nStep 4: Modify the Latex writeup in ./writeup/archlab.tex to reflect the handout and handin directions for your site. If you don\u0026rsquo;t use Latex, use your favorite document preparation system to prepare Postcript and PDF versions of the writeup in archlab.pdf.\nStep 5: Modify ./Makefile with the name of the lab (LABNAME) and the name of the directory where the handout tarfile will be copied to and where the students can pick it from (DEST). LABNAME is typically archlab.\nStep 6: In the same directory as this README file, type\nmake clean; make  to the shell. This will do the following things:\n(a) Compile the master distribution of the Y86-64 tools in ./src (b) Build the student distribution in ./sim (c) Build a tarfile of the student distribution\tin sim.tar (d) Build a handout directory ./$(LABNAME)-handout (e) Build the $(LABNAME)-handout.tar file that you will be handing out to students.\nStep 7: Type \u0026ldquo;make dist\u0026rdquo; to copy the $(LABNAME)-handout.tar file and the writeup to the distribution directory where the students will retrieve the lab.\n4. Grading the Lab #  There are Perl autograding scripts for each part of this lab. See ./grade/README for details.\n5. Notes #    If you are running in GUI mode, you\u0026rsquo;ll need to install Tcl/Tk along with the Tcl and Tk developer\u0026rsquo;s packages. On an Ubuntu machine:\nlinux\u0026gt; sudo apt-get tcl tcl-dev tk tk-dev\n  If you are running in GUI mode on a system with X windows, make sure that your DISPLAY environment variable is set:\nlinux\u0026gt; setenv DISPLAY mymachine.myschool.edu:0\nIf you\u0026rsquo;re using ssh, you can set the DISPLAY variable automatically by using the \u0026ldquo;ssh -X hostname\u0026rdquo; command.\n  The lab compiles with no warnings and passes all regression tests on the following systems:\n Linux/2.2.20, Pentium III, gcc 2.95.3, Gnu make, Perl 5 Solaris/5.8, Sparc Ultra 80, gcc 2.95.3, Sun make, Perl 5 Linux/2.6.18, Intel x86_64, gcc 4.3.5, Perl 5.8.8    The autograders for parts B and C run the regression tests in ptest/ as part of the evaluation of the student solutions. On older systems, these tests can take a long time, 5 minutes or so, with most of the time being spent by the htest.pl script. If this is too long, you can sacrifice completeness for speed by commenting out the call to htest.pl in ptest/Makefile.\n  "},{"id":4,"href":"/uni/docs/books/computer_systems_app/labs/attack/","title":"Attack","section":"Labs","content":"Attack Lab #   üëã Note: This is the 64-bit successor to the 32-bit Buffer Lab. Students are given a pair of unique custom-generated x86-64 binary executables, called targets, that have buffer overflow bugs. One target is vulnerable to code injection attacks. The other is vulnerable to return-oriented programming attacks. Students are asked to modify the behavior of the targets by developing exploits based on either code injection or return-oriented programming. This lab teaches the students about the stack discipline and teaches them about the danger of writing code that is vulnerable to buffer overflow attacks.\n Contents #   Files downloaded from CS:APP website as target1.tar, and listed below in the original README contents  Lab Assignment Write-Up #  csapp.cs.cmu.edu/3e/attacklab.pdf.\nThis write-up is very helpful for even those doing self-study. Read through it to learn how to approach this lab\u0026rsquo;s problem(s).\nOriginal README.md #  This section is copied from csapp.cs.cmu.edu/3e/README-attacklab. It was modified only to conform to standard Markdown formatting.\nIt is not particularly useful for people doing self-study, but is reproduced here anyway.\n ################################################## # CS:APP Attack Lab # Directions to Instructors # # Copyright (c) 2016, R. Bryant and D. O'Hallaron # ################################################## This directory contains the files that you will use to build and run the CS:APP Attack Lab.\nThe purpose of the Attack Lab is to help students develop a detailed understanding of the stack discipline on x86-64 processors. It involves applying a total of five buffer overflow attacks on some executable files. There are three code injection attacks and two return-oriented programming attacks.\nThe lab must be done on an x86-64 Linux system. It requires a version of gcc that supports the -Og optimization flag (e.g., gcc 4.8.1). We\u0026rsquo;ve tested it at CMU on Ubuntu 12.4 systems.\n1. Overview #  1.1. Targets #  Students are given binaries called ctarget and rtarget that have a buffer overflow bug. They are asked to alter the behavior of their targets via five increasingly difficult exploits. The three attacks on ctarget use code injection. The two attacks on rtarget use return-oriented programming.\n1.2. Solving Targets #  Each exploit involves reading a sequence of bytes from standard input into a buffer stored on the stack. Students encode each exploit string as a sequence of hex digit pairs separated by whitespace, where each hex digit pair represents a byte in the exploit string. The program \u0026ldquo;hex2raw\u0026rdquo; converts these strings into a sequence of raw bytes, which can then be fed to the target:\nunix\u0026gt; cat exploit.txt | ./hex2raw | ./ctarget  Each student gets their own custom-generated copy of ctarget and rtarget. Thus, students must develop the solutions on their own and cannot use the solutions from other students.\nThe lab writeup has extensive details on each phase and solution techniques. We suggest that you read the writeup carefully before continuing with this README file.\n1.3. Autograding Service #  As with the Bomb and Bufer Labs, we have created a stand-alone user-level autograding service that handles all aspects of the Attack Lab for you: Students download their targets from a server. As the students work on their targets, each successful solution is streamed back to the server. The current results for each target are displayed on a Web \u0026ldquo;scoreboard.\u0026rdquo; There are no explicit handins and the lab is self-grading.\nThe autograding service consists of four user-level programs that run in the main ./attacklab directory:\n  Request Server (attacklab-requestd.pl). Students download their targets and display the scoreboard by pointing a browser at a simple HTTP server called the \u0026ldquo;request server.\u0026rdquo; The request server builds the target files, archives them in a tar file, and then uploads the resulting tar file back to the browser, where it can be saved on disk and untarred. The request server also creates a copy of the targets and their solutions for the instructor in the targets/ directory.\n  Result Server (attacklab-resultd.pl). Each time a student correctly solves a target phase, the target sends a short HTTP message, called an \u0026ldquo;autoresult string,\u0026rdquo; to an HTTP \u0026ldquo;result server,\u0026rdquo; which simply appends the autoresult string to a \u0026ldquo;scoreboard log file\u0026rdquo; called log.txt.\n  Report Daemon (attacklab-reportd.pl). The \u0026ldquo;report daemon\u0026rdquo; periodically scans the scoreboard log file. The report daemon finds the most recent autoresult string submitted by each student for each phase, and validates these strings by applying them to a local copy of the student\u0026rsquo;s targets. It then updates the HTML scoreboard (attacklab-scoreboard.html) that summarizes the current number of solutions for each target, rank ordered by the total number of accrued points.\n  Main daemon (attacklab.pl). The \u0026ldquo;main daemon\u0026rdquo; starts and nannies the request server, result server, and report daemon, ensuring that exactly one of these processes (and itself) is running at any point in time. If one of these processes dies for some reason, the main daemon detects this and automatically restarts it. The main daemon is the only program you actually need to run.\n  2. Files #  The ./attacklab directory contains the following files:\n Makefile - For starting/stopping the lab and cleaning files attacklab.pl* - Main daemon that nannies the other servers \u0026amp; daemons Attacklab.pm - Attacklab configuration file attacklab-reportd.pl* - Report daemon that continuously updates scoreboard attacklab-requestd.pl* - Request server that serves targets to students attacklab-resultd.pl* - Result server that gets autoresult strings from targets attacklab-scoreboard.html - Real-time Web scoreboard attacklab-update.pl - Helper to attacklab-reportd.pl that updates scoreboard targets/ - Contains unique targets generated for each student, with solutions log-status.txt - Status log with msgs from various servers and daemons log.txt - Scoreboard log of autoresults received from targets scores.csv - Summarizes current scoreboard scores for each student src/ - Attacklab source files validate.pl - Called periodically by report daemon. Validates solutions for each student, and updates scoreboard and scores files. writeup/ - Sample Latex Attack Lab writeup  3. Solutions #  TargetID: Each target in a given instance of the lab has a unique non-negative integer called the \u0026ldquo;targetID.\u0026rdquo;\nThe five solutions for target n are avalable to you in the targets/target directory, in the following files:\n Phase 1: ctarget.l1, Phase 2: ctarget.l2, Phase 3: ctarget.l3, Phase 4: rtarget.l2, Phase 5: rtarget.l3,  where \u0026ldquo;l\u0026rdquo; stands for level.\n4. Offering the Attack Lab #  There are two basic flavors of the Attack Lab: In the \u0026ldquo;online\u0026rdquo; version, the instructor uses the autograding service to handout custom targets to each student on demand, and to automatically track their progress on the realtime scoreboard. In the \u0026ldquo;offline\u0026rdquo; version, the instructor builds, hands out, and grades the student targets manually, without using the autograding service.\nWhile both versions give the students a rich experience, we recommend the online version. It is clearly the most compelling and fun for the students, and the easiest for the instructor to grade. However, it requires that you keep the autograding service running non-stop, because handouts, grading, and reporting occur continuously for the duration of the lab. We\u0026rsquo;ve made it very easy to run the service, but some instructors may be uncomfortable with this requirement and will opt instead for the offline version.\nHere are the directions for offering both versions of the lab.\n4.1. Create a Clean Attack Lab Directory #  Identify the Linux machine ($SERVER_NAME) where you will create the Attack Lab directory (./attacklab) and, if you are offering the online version, will run the autograding service. You\u0026rsquo;ll only need to have a user account on this machine. You don\u0026rsquo;t need root access.\nThe machine must be x86-64 and have a relatively recent version of gcc that supports the -Og optimization flag (e.g., gcc 4.8.1).\nEach offering of the Attack Lab must start with a clean new ./attacklab directory on $SERVER_NAME. For example:\nlinux\u0026gt; tar xvf attacklab.tar linux\u0026gt; cd attacklab linux\u0026gt; make cleanallfiles  4.2 Configure the Attack Lab #  If you are offering the online version, you will need to edit the following files:\n  ./Attacklab.pm - This is the main configuration file. You will only need to modify or inspect a few variables in Section 1 of this file. Each variable is preceded by a descriptive comment.\n  ./src/build/config.c - This file gives the course number and lists the domain names of the hosts that targets are allowed to run on. Make sure you update this correctly, else you and your students won\u0026rsquo;t be able to run your targets. You should include $SERVER_NAME (the machine running the attacklab servers) in this list, along with any machines that your students are allowed to submit from.\n  ./src/build/driverhdrs.h - This file provides the SERVER_NAME where the attacklab servers are running. It must be identical to the $SERVER_NAME in Attacklab.pm.\n  4.3. Update the Lab Writeup #  Modify the Latex lab writeup in ./writeup/attacklab.tex for your environment. Then type the following in the ./writeup directory:\nunix\u0026gt; make clean; make  4.4. Offering the Online Attack Lab #  4.4.1. Short Version #  From the ./attacklab directory:\n(1) Reset the Attack Lab from scratch once by typing linux\u0026gt; make cleanallfiles\n(2) Start the autograding service by typing linux\u0026gt; make start\n(3) Stop the autograding service by typing linux\u0026gt; make stop\nYou can start and stop the autograding service as often as you like without losing any information. When in doubt \u0026ldquo;make stop; make start\u0026rdquo; will get everything in a stable state.\nHowever, resetting the lab deletes all old targets, status logs, and the scoreboard log. Do this only during debugging, or the very first time you start the lab for your students.\nStudents request their custom targets by pointing their browsers at http://$SERVER_NAME:15513/\nStudents view the scoreboard by pointing their browsers at http://$SERVER_NAME:15513/scoreboard\nwhere $SERVER_NAME is defined in Attacklab.pm.\n4.4.2. Long Version #  (1) Resetting the Attack Lab. \u0026ldquo;make stop\u0026rdquo; ensures that there are no servers running. \u0026ldquo;make cleanallfiles\u0026rdquo; resets the lab from scratch, deleting all data specific to a particular instance of the lab, such as the status log, all targets created by the request server, and the scoreboard log. Do this when you\u0026rsquo;re ready for the lab to go \u0026ldquo;live\u0026rdquo; to the students.\nResetting is also useful while you\u0026rsquo;re preparing the lab. Before the lab goes live, you\u0026rsquo;ll want to request a few targets for yourself, run them, solve a few phases (using the solutions provided to instructors in the targets directory), and make sure that the results are displayed properly on the scoreboard. If there is a problem (say because you forgot to update the list of machines the targets are allowed to run on in src/build/config.c) you stop the servers, fix the configuration, reset the lab, and then request and run more test targets.\nCAUTION: If you reset the lab after it\u0026rsquo;s live, you\u0026rsquo;ll lose all your records of the students' targets and their solutions. You won\u0026rsquo;t be able to validate the students' handins. And your students will have to get new targets and start over.\n(2) Starting the Attack Lab. \u0026ldquo;make start\u0026rdquo; runs attacklab.pl, the main daemon that starts and nannies the other programs in the service, checking their status every few seconds and restarting them if necessary:\n(3) Stopping the Attack Lab. \u0026ldquo;make stop\u0026rdquo; kills all of the running servers. You can start and stop the autograding service as often as you like without losing any information. When in doubt \u0026ldquo;make stop; make start\u0026rdquo; will get everything in a stable state.\nRequest Server: The request server is a simple special-purpose HTTP server that (1) builds and delivers custom targets to student browsers on demand, and (2) displays the current state of the real-time scoreboard.\nA student requests a target from the request daemon in two steps: First, the student points their favorite browser at\nhttp://$SERVER_NAME:15513/  For example, http://foo.cs.cmu.edu:15513/. The request server responds by sending an HTML form back to the browser. Next, the student fills in this form with their user name and email address, and then submits the form. The request server parses the form, builds and tars up a target with targetID=n, and delivers the tar file to the browser. The student then saves the tar file to disk. When the student untars this file, it creates a directory (./target) with the following files:\n  README.txt: A file describing the contents of the directory.\n  ctarget: An executable program vulnerable to code-injection attacks.\n  rtarget: An executable program vulnerable to return-oriented programming attacks.\n  cookie.txt: An 8-digit hex code that serves as a unique identifier in the attacks submitted to the results server.\n  farm.c: The source code of this target\u0026rsquo;s ``gadget farm,'' which are used in generating return-oriented programming attacks.\n  hex2raw: A utility to generate attack strings.\n  The request server also creates a directory (attacklab/targets/target) that contains these files, along with the solutions for each of the five phases. See the targets/target/README.txt for details.\nResult Server: Each time a student successfully solves a phase, the target sends an HTTP message (called an autoresult string) to the result server, which then appends the message to the scoreboard log. Each message contains a targetID, the phase number, and the exploit string.\nReport Daemon: The report daemon periodically scrapes the scoreboard log, validates the most recent submission from each target, and updates the Web scoreboard with the results rank-ordered by score and submission time. It also creates a CSV file with the scores for each student. The update frequency is a configuration variable in Attacklab.pm.\nInstructors and students view the scoreboard by pointing their browsers at:\nhttp://$SERVER_NAME:15513/scoreboard  4.4.3. Grading the Online Attack Lab #  The online Attack Lab is self-grading. At any point in time, the CSV file ./attacklab/scores.csv contains the most recent scores for each student. This file is created by the report daemon each time it generates a new scoreboard.\n4.4.4. Additional Notes on the Online Attack Lab #    Since the request server and report daemon both need to execute targets, you must include $SERVER_NAME in the list of legal machines in your attacklab/src/build/config.c file.\n  All of the servers and daemons are stateless, so you can stop (\u0026ldquo;make stop\u0026rdquo;) and start (\u0026ldquo;make start\u0026rdquo;) the lab as many times as you like without any ill effects. If you accidentally kill one of the daemons, or you modify a daemon, or the daemon dies for some reason, then use \u0026ldquo;make stop\u0026rdquo; to clean up, and then restart with \u0026ldquo;make start\u0026rdquo;. If your Linux box crashes or reboots, simply restart the daemons with \u0026ldquo;make start\u0026rdquo;.\n  Information and error messages from the servers are appended to the \u0026ldquo;status log\u0026rdquo; in attack/log-status.txt. Servers run quietly, so they can be started from initrc scripts at boot time.\n  See the README files in src/build/ and src/solve for details about how targets are constructed and solved. Not necessary, but included for completeness.\n  Before going live with the students, we like to check everything out by running some tests. We do this by typing\nlinux\u0026gt; make cleanallfiles\nlinux\u0026gt; make start\n  Then we request a target for ourselves by pointing a Web browser at\nhttp://$SERVER_NAME:15513  After saving our target to disk, we untar it, copy it to a host in the approved list in src/build/config.c, and then solve it using the solution files in targets/target: ctarget.l1, ctarget.l2, ctarget.l3, rtarget.l2, and rtarget.l3.\nThen we check the scoreboard to see that it\u0026rsquo;s being updated correctly: recorded on the scoreboard, which we check at\nhttp://$SERVER_NAME:15513/scoreboard  Once we\u0026rsquo;re satisfied that everything is OK, we stop the lab\nlinux\u0026gt; make stop  and then go live:\nlinux\u0026gt; make cleanallfiles linux\u0026gt; make start  Once we go live, we type \u0026ldquo;make stop\u0026rdquo; and \u0026ldquo;make start\u0026rdquo; as often as we need to, but we are careful never to type \u0026ldquo;make cleanallfiles\u0026rdquo; again.\n4.5. Offering the Offline Attack Lab #  In this version of the lab, you build your own custom targets manually and then hand them out to the students. The students work on solving their targets offline (i.e., independently of any autograding service) and then handin their solution files to you, each of which you grade manually by feeding the exploit strings to the copy of the student\u0026rsquo;s targets.\nYou generate targets manually using the the src/build/buildtarget.pl script, which must be run from the src/build directory. For example, to generate target 2 for user bovik:\nlinux\u0026gt; cd src/build linux\u0026gt; ./buildtarget.pl -u bovik -t 2  This will generate a file called targets/target2.tar, which you then hand out to the student.\nStudents will need to run ctarget and rtarget using the -q option, which tells the targets not to try to contact the (non-existent) grading server.\nThe student will hand in up to five exploit strings: bovik-ctarget.l1, bovik-ctarget.l2, bovik-ctarget.l3, bovik-rtarget.l2, and bovik-rtarget.l3. You evaluate each exploit by feeding it to the ctarget or rtarget programs in the targets/target2directory. For example:\nlinux\u0026gt; cat bovik-ctarget.l3 | ./src/hex2raw | ./targets/target2/ctarget -q linux\u0026gt; cat bovik-rtarget.l2 | ./src/hex2raw | ./targets/target2/rtarget -q  "},{"id":5,"href":"/uni/docs/books/computer_systems_app/labs/binary_bomb/","title":"Binary Bomb","section":"Labs","content":"Binary Bomb Lab #  Contents #   bomb: The executable binary bomb. bomb.c: Source file with the bomb‚Äôs main routine and a friendly greeting from Dr. Evil Solution Details: TODO üöß  I think the bomb.c file is not intended to be compiled and run, just read.\nLab Assignment Write-Up #  csapp.cs.cmu.edu/3e/bomblab.pdf.\nThis write-up is pretty helpful for even those doing self-study. Read through it to learn how to approach this lab\u0026rsquo;s problem.\nOriginal README.md #  This section is copied from csapp.cs.cmu.edu/3e/README-bomblab. It was modified only to conform to standard Markdown formatting.\nIt is not particularly useful for people doing self-study, but is reproduced here anyway.\n ####################################################### # CS:APP Bomb Lab # Directions to Instructors # # Copyright (c) 2003-2016, R. Bryant and D. O'Hallaron # ####################################################### This directory contains the files that you will use to build and run the CS:APP Bomb Lab. The Bomb Lab teaches students principles of machine-level programs, as well as general debugger and reverse engineering skills.\n1. Overview #  1.1. Binary Bombs #  A \u0026ldquo;binary bomb\u0026rdquo; is a Linux executable C program that consists of six \u0026ldquo;phases.\u0026rdquo; Each phase expects the student to enter a particular string on stdin. If the student enters the expected string, then that phase is \u0026ldquo;defused.\u0026rdquo; Otherwise the bomb \u0026ldquo;explodes\u0026rdquo; by printing \u0026ldquo;BOOM!!!\u0026rdquo;. The goal for the students is to defuse as many phases as possible.\n1.2. Solving Binary Bombs #  In order to defuse the bomb, students must use a debugger, typically gdb or ddd, to disassemble the binary and single-step through the machine code in each phase. The idea is to understand what each assembly statement does, and then use this knowledge to infer the defusing string. Students earn points for defusing phases, and they lose points (configurable by the instructor, but typically 1/2 point) for each explosion. Thus, they quickly learn to set breakpoints before each phase and the function that explodes the bomb. It\u0026rsquo;s a great lesson and forces them to learn to use a debugger.\n1.3. Autograding Service #  We have created a stand-alone user-level autograding service that handles all aspects of the Bomb Lab for you: Students download their bombs from a server. As the students work on their bombs, each explosion and defusion is streamed back to the server, where the current results for each bomb are displayed on a Web \u0026ldquo;scoreboard.\u0026rdquo; There are no explicit handins and the lab is self-grading.\nThe autograding service consists of four user-level programs that run in the main ./bomblab directory:\n  Request Server (bomblab-requestd.pl). Students download their bombs and display the scoreboard by pointing a browser at a simple HTTP server called the \u0026ldquo;request server.\u0026rdquo; The request server builds the bomb, archives it in a tar file, and then uploads the resulting tar file back to the browser, where it can be saved on disk and untarred. The request server also creates a copy of the bomb and its solution for the instructor.\n  Result Server (bomblab-resultd.pl). Each time a student defuses a bomb phase or causes an explosion, the bomb sends a short HTTP message, called an \u0026ldquo;autoresult string,\u0026rdquo; to an HTTP \u0026ldquo;result server,\u0026rdquo; which simply appends the autoresult string to a \u0026ldquo;scoreboard log file.\u0026rdquo;\n  Report Daemon (bomblab-reportd.pl). The \u0026ldquo;report daemon\u0026rdquo; periodically scans the scoreboard log file. The report daemon finds the most recent defusing string submitted by each student for each phase, and validates these strings by applying them to a local copy of the student\u0026rsquo;s bomb. It then updates the HTML scoreboard that summarizes the current number of explosions and defusions for each bomb, rank ordered by the total number of accrued points.\n  Main daemon (bomblab.pl). The \u0026ldquo;main daemon\u0026rdquo; starts and nannies the request server, result server, and report deamon, ensuring that exactly one of these processes (and itself) is running at any point in time. If one of these processes dies for some reason, the main daemon detects this and automatically restarts it. The main daemon is the only program you actually need to run.\n  2. Files #  The ./bomblab directory contains the following files:\nMakefile - For starting/stopping the lab and cleaning files bomblab.pl* - Main daemon that nannies the other servers \u0026amp; daemons Bomblab.pm - Bomblab configuration file bomblab-reportd.pl* - Report daemon that continuously updates scoreboard bomblab-requestd.pl* - Request server that serves bombs to students bomblab-resultd.pl* - Result server that gets autoresult strings from bombs bomblab-scoreboard.html - Real-time Web scoreboard bomblab-update.pl* - Helper to bomblab-reportd.pl that updates scoreboard bombs/ - Contains the bombs sent to each student log-status.txt - Status log with msgs from various servers and daemons log.txt - Scoreboard log of autoresults received from bombs makebomb.pl* - Helper script that builds a bomb scores.txt - Summarizes current scoreboard scores for each student src/ - The bomb source files writeup/ - Sample Latex Bomb Lab writeup\n3. Bomb Terminology #  LabID: Each instance (offering) of the lab is identified by a unique name, e.g., \u0026ldquo;f12\u0026rdquo; or \u0026ldquo;s13\u0026rdquo;, that the instructor chooses. Explosion and diffusions from bombs whose LabIDs are different from the current LabID are ignored. The LabID must not have any spaces.\nBombID: Each bomb in a given instance of the lab has a unique non-negative integer called the \u0026ldquo;bombID.\u0026rdquo;\nNotifying Bomb: A bomb can be compiled with a NOTIFY option that causes the bomb to send a message each time the student explodes or defuses a phase. Such bombs are called \u0026ldquo;notifying bombs.\u0026rdquo;\nQuiet Bomb: If compiled with the NONOTIFY option, then the bomb doesn\u0026rsquo;t send any messages when it explodes or is defused. Such bombs are called \u0026ldquo;quiet bombs.\u0026rdquo;\nWe will also find it helpful to distinguish between custom and generic bombs:\nCustom Bomb: A \u0026ldquo;custom bomb\u0026rdquo; has a BombID \u0026gt; 0, is associated with a particular student, and can be either notifying or quiet. Custom notifying bombs are constrained to run on a specific set of Linux hosts determined by the instructor. On the other hand, custom quiet bombs can run on any Linux host.\nGeneric Bomb: A \u0026ldquo;generic bomb\u0026rdquo; has a BombID = 0, isn\u0026rsquo;t associated with any particular student, is quiet, and hence can run on any host.\n4. Offering the Bomb Lab #  There are two basic flavors of Bomb Lab: In the \u0026ldquo;online\u0026rdquo; version, the instructor uses the autograding service to handout a custom notifying bomb to each student on demand, and to automatically track their progress on the realtime scoreboard. In the \u0026ldquo;offline\u0026rdquo; version, the instructor builds, hands out, and grades the student bombs manually, without using the autograding service.\nWhile both version give the students a rich experience, we recommend the online version. It is clearly the most compelling and fun for the students, and the easiest for the instructor to grade. However, it requires that you keep the autograding service running non-stop, because handouts, grading, and reporting occur continuously for the duration of the lab. We\u0026rsquo;ve made it very easy to run the service, but some instructors may be uncomfortable with this requirement and will opt instead for the offline version.\nHere are the directions for offering both versions of the lab.\n4.1. Create a Bomb Lab Directory #  Identify the generic Linux machine ($SERVER_NAME) where you will create the Bomb Lab directory (./bomblab) and, if you are offering the online version, run the autograding service. You\u0026rsquo;ll only need to have a user account on this machine. You don\u0026rsquo;t need root access.\nEach offering of the Bomb Lab starts with a clean new ./bomblab directory on $SERVER_NAME. For example:\nlinux\u0026gt; tar xvf bomblab.tar linux\u0026gt; cd bomblab linux\u0026gt; make cleanallfiles  4.2 Configure the Bomb Lab #  Configure the Bomb Lab by editing the following file:\n./Bomblab.pm - This is the main configuration file. You will only need to modify or inspect a few variables in Section 1 of this file. Each variable is preceded by a descriptive comment. If you are offering the offline version, you can ignore most of these settings.\nIf you are offering the online version, you will also need to edit the following file:\n./src/config.h - This file lists the domain names of the hosts that notifying bombs are allowed to run on. Make sure you update this correctly, else you and your students won\u0026rsquo;t be able to run your bombs.\n4.3. Update the Lab Writeup #  Once you have updated the configuration files, modify the Latex lab writeup in ./writeup/bomblab.tex for your environment. Then type the following in the ./writeup directory:\nunix\u0026gt; make clean unix\u0026gt; make This will create ps and pdf versions of the writeup\n4.4. Running the Online Bomb Lab #  4.4.1. Short Version #  From the ./bomblab directory:\n(1) Reset the Bomb Lab from scratch by typing make cleanallfiles\n(2) Start the autograding service by typing make start\n(3) Stop the autograding service by typing make stop\nYou can start and stop the autograding service as often as you like without losing any information. When in doubt \u0026ldquo;make stop; make start\u0026rdquo; will get everything in a stable state.\nHowever, resetting the lab deletes all old bombs, status logs, and the scoreboard log. Do this only during debugging, or the very first time you start the lab for your students.\nStudents request bombs by pointing their browsers at http://$SERVER_NAME:$REQUESTD_PORT/\nStudents view the scoreboard by pointing their browsers at http://$SERVER_NAME:$REQUESTD_PORT/scoreboard\n4.4.2. Long Version #  (1) Resetting the Bomb Lab. \u0026ldquo;make stop\u0026rdquo; ensures that there are no servers running. \u0026ldquo;make cleanallfiles\u0026rdquo; resets the lab from scratch, deleting all data specific to a particular instance of the lab, such as the status log, all bombs created by the request server, and the scoreboard log. Do this when you\u0026rsquo;re ready for the lab to go \u0026ldquo;live\u0026rdquo; to the students.\nResetting is also useful while you\u0026rsquo;re preparing the lab. Before the lab goes live, you\u0026rsquo;ll want to request a few bombs for yourself, run them, defuse a few phases, explode a few phases, and make sure that the results are displayed properly on the scoreboard. If there is a problem (say because you forgot to update the list of machines the bombs are allowed to run in src/config.h) you can fix the configuration, reset the lab, and then request and run more test bombs.\nCAUTION: If you reset the lab after it\u0026rsquo;s live, you\u0026rsquo;ll lose all your records of the students bombs and their solutions. You won\u0026rsquo;t be able to validate the students handins. And your students will have to get new bombs and start over.\n(2) Starting the Bomb Lab. \u0026ldquo;make start\u0026rdquo; runs bomblab.pl, the main daemon that starts and nannies the other programs in the service, checking their status every few seconds and restarting them if necessary:\n(3) Stopping the Bomb Lab. \u0026ldquo;make stop\u0026rdquo; kills all of the running servers. You can start and stop the autograding service as often as you like without losing any information. When in doubt \u0026ldquo;make stop; make start\u0026rdquo; will get everything in a stable state.\nRequest Server: The request server is a simple special-purpose HTTP server that (1) builds and delivers custom bombs to student browsers on demand, and (2) displays the current state of the real-time scoreboard.\nA student requests a bomb from the request daemon in two steps: First, the student points their favorite browser at http://$SERVER_NAME:$REQUESTD_PORT/.\nFor example, http://foo.cs.cmu.edu:15213/. The request server responds by sending an HTML form back to the browser. Next, the student fills in this form with their user name and email address, and then submits the form. The request server parses the form, builds and tars up a notifying custom bomb with bombID=n, and delivers the tar file to the browser. The student then saves the tar file to disk. When the student untars this file, it creates a directory (./bomb) with the following four files:\nbomb* Notifying custom bomb executable bomb.c Source code for the main bomb routine ID Identifies the student associated with this bomb README Lists bomb number, student, and email address The request server also creates a directory (bomblab/bombs/bomb) that contains the following files:\nbomb* Custom bomb executable bomb.c Source code for main routine bomb-quiet* A quiet version of bomb used for autograding ID Identifies the user name assigned to this bomb phases.c C source code for the bomb phases README Lists bombID, user name, and email address solution.txt The solution for this bomb Result Server: Each time a student defuses a phase or explodes their bomb, the bomb sends an HTTP message (called an autoresult string) to the result server, which then appends the message to the scoreboard log. Each message contains a BombID, a phase, and an indication of the event that occurred. If the event was a defusion, the message also contains the \u0026ldquo;defusing string\u0026rdquo; that the student typed to defuse the phase.\nReport Daemon: The report daemon periodically scans the scoreboard log and updates the Web scoreboard. For each bomb, it tallies the number of explosions, the last defused phase, validates each last defused phase using a quiet copy of the bomb, and computes a score for each student in a tab delimited text file called \u0026ldquo;scores.txt.\u0026rdquo; The update frequency is a configuration variable in Bomblab.pm.\nInstructors and students view the scoreboard by pointing their browsers at: http://$SERVER_NAME:$REQUESTD_PORT/scoreboard\n4.4.3. Grading the Online Bomb Lab #  The online Bomb Lab is self-grading. At any point in time, the tab-delimited file (./bomblab/scores.txt) contains the most recent scores for each student. This file is created by the report daemon each time it generates a new scoreboard.\n4.4.4. Additional Notes on the Online Bomb Lab #    Since the request server and report daemon both need to execute bombs, you must include $SERVER_NAME in the list of legal machines in your bomblab/src/config.h file.\n  All of the servers and daemons are stateless, so you can stop (\u0026ldquo;make stop\u0026rdquo;) and start (\u0026ldquo;make start\u0026rdquo;) the lab as many times as you like without any ill effects. If you accidentally kill one of the daemons, or you modify a daemon, or the daemon dies for some reason, then use \u0026ldquo;make stop\u0026rdquo; to clean up, and then restart with \u0026ldquo;make start\u0026rdquo;. If your Linux box crashes or reboots, simply restart the daemons with \u0026ldquo;make start\u0026rdquo;.\n  Information and error messages from the servers are appended to the \u0026ldquo;status log\u0026rdquo; in bomblab/log-status.txt. Servers run quietly, so they can be started from initrc scripts at boot time.\n  See src/README for more information about the anatomy of bombs and how they are constructed. You don\u0026rsquo;t need to understand any of this to offer the lab. It\u0026rsquo;s provided only for completeness.\n  Before going live with the students, we like to check everything out by running some tests. We do this by typing\n  linux\u0026gt; make cleanallfiles linux\u0026gt; make start Then we request a bomb for ourselves by pointing a Web browser at http://$SERVER_NAME:$REQUESTD_PORT\nAfter saving our bomb to disk, we untar it, copy it to a host in the approved list in src/config.h, and then explode and defuse it a couple of times to make sure that the explosions and diffusion are properly recorded on the scoreboard, which we check at http://$SERVER_NAME:$REQUESTD_PORT/scoreboard\nOnce we\u0026rsquo;re satisfied that everything is OK, we stop the lab\nlinux\u0026gt; make stop and then go live:\nlinux\u0026gt; make cleanallfiles linux\u0026gt; make start Once we go live, we type \u0026ldquo;make stop\u0026rdquo; and \u0026ldquo;make start\u0026rdquo; as often as we need to, but we are careful never to type \u0026ldquo;make cleanallfiles\u0026rdquo; again.\n4.5. Running the Offline Bomb Lab #  In this version of the lab, you build your own quiet bombs manually and then hand them out to the students. The students work on defusing their bombs offline (i.e., independently of any autograding service) and then handin their solution files to you, each of which you grade manually.\nYou can use the makebomb.pl script to build your own bombs manually. The makebomb.pl script also generates the bomb\u0026rsquo;s solution. Type \u0026ldquo;./makebomb.pl -h\u0026rdquo; to see its arguments.\nOption 1: The simplest approach for offering the offline Bomb Lab is to build a single generic bomb that every student attempts to defuse:\nlinux\u0026gt; ./makebomb.pl -s ./src -b ./bombs This will create a generic bomb and some other files in ./bombs/bomb0:\nbomb* Generic bomb executable (handout to students) bomb.c Source code for main routine (handout to students) bomb-quiet* Ignore this ID Ignore this phases.c C source code for the bomb phases README Ignore this solution.txt The solution for this bomb You will handout only two of these files to the students: ./bomb and ./bomb.c\nThe students will handin their solution files, which you can validate by feeding to the bomb:\nlinux\u0026gt; cd bombs/bomb0 linux\u0026gt; ./bomb \u0026lt; student_solution.txt This option is easy for the instructor, but we don\u0026rsquo;t recommend it because it is too easy for the students to cheat.\nOption 2. The other option for offering an offline lab is to use the makebomb.pl script to build a unique quiet custom bomb for each student:\nlinux\u0026gt; ./makebomb.pl -i \u0026lt;n\u0026gt; -s ./src -b ./bombs -l bomblab -u \u0026lt;email\u0026gt; -v \u0026lt;uid\u0026gt; This will create a quiet custom bomb in ./bombs/bomb for the student whose email address is  and whose user name is :\nbomb* Custom bomb executable (handout to student) bomb.c Source code for main routine (handout to student) bomb-quiet* Ignore this ID Identifies the student associated with this bomb phases.c C source code for the bomb phases README Lists bomb number, student, and email address solution.txt The solution for this bomb You will handout four of these files to the student: bomb, bomb.c, ID, and README.\nEach student will hand in their solution file, which you can validate by hand by running their custom bomb against their solution:\nlinux\u0026gt; cd ./bombs/bomb\u0026lt;n\u0026gt; linux\u0026gt; ./bomb \u0026lt; student_n_solution.txt The source code for the different phase variants is in ./src/phases/.\n"},{"id":6,"href":"/uni/docs/books/computer_systems_app/labs/buffer/","title":"Buffer","section":"Labs","content":"Buffer Lab #   ‚ö†Ô∏è Note: This is the legacy 32-bit lab from CS:APP2e. It has been replaced by the Attack Lab. In the Buffer Lab, students modify the run-time behavior of a 32-bit x86 binary executable by exploiting a buffer overflow bug. This lab teaches the students about the stack discipline and teaches them about the danger of writing code that is vulnerable to buffer overflow attacks.\n Contents #   Files downloaded from CS:APP website as buflab32-handout.tar, and listed below in the original README contents  I think the bomb.c file is not intended to be compiled and run, just read.\nLab Assignment Write-Up #  csapp.cs.cmu.edu/3e/buflab32.pdf.\nThis write-up is pretty helpful for even those doing self-study. Read through it to learn how to approach this lab\u0026rsquo;s problem.\nOriginal README.md #  This section is copied from csapp.cs.cmu.edu/3e/README-buflab32. It was modified only to conform to standard Markdown formatting.\nIt is not particularly useful for people doing self-study, but is reproduced here anyway.\n ##################################################################### # CS:APP Buffer Lab # Directions to Instructors # # Copyright (c) 2002-2012, R. Bryant and D. O'Hallaron # ###################################################################### This directory contains the files that you will use to build and run the CS:APP Buffer Lab.\nThe purpose of the Buffer Lab is to help students develop a detailed understanding of the stack discipline on IA32 processors. It involves applying a series of buffer overflow attacks on an executable file.\nThis version of the lab has been specially modified to defeat the stack randomization techniques used by newer versions of Linux. It works by using mmap() and an assembly language insert to move the stack pointed at by %esp to an unused part of the heap.\n1. Overview #  1.1. Buffer Bombs #  A \u0026ldquo;buffer bomb\u0026rdquo; is an executable bomb, called \u0026ldquo;./bufbomb\u0026rdquo;, that is solved using a buffer overflow attack (exploit). In this lab, students are asked to alter the behavior of a buffer bomb (called bufbomb) via five increasingly difficult levels of exploits.\nThe levels are called smoke (level 0), fizz (level 1), bang (level 2), boom (level 3), and kaboom (level 4), with smoke being the simplest and kaboom being the most difficult.\n1.2. Solving Buffer Bombs #  Each exploit involves reading a sequence of bytes from standard input into a buffer stored on the stack. Students encode each exploit string as a sequence of hex digit pairs separated by whitespace, where each hex digit pair represents a byte in the exploit string. The program \u0026ldquo;hex2raw\u0026rdquo; converts these strings into a sequence of raw bytes, which can then fed to the buffer bomb:\nunix\u0026gt; cat exploit.txt | ./hex2raw | ./bufbomb -u \u0026lt;userid\u0026gt;  Each student works on an identical buffer bomb, but the solution to the individual phases is a function of each student\u0026rsquo;s userid. Thus, students must develop the solution on their own and cannot use the solutions from other students.\nThe solution to each phase is unique for each student because it typically involves the manipulation on the runtime stack of a unique \u0026ldquo;cookie\u0026rdquo; computed from the userid by the \u0026ldquo;makecookie\u0026rdquo; program:\nunix\u0026gt; ./makecookie bovik 0x1005b2b7  The lab writeup has extensive details on each phase and solution techniques.\n1.3. Autograding Service #  We have provided the same stand-alone user-level autograding service used by the Bomb Lab to handle all aspects of the Buffer Lab for you. Students download their buffer bombs from a server. As the students work on their bombs, they can submit successful exploit strings to the server by running the buffer bomb with \u0026ldquo;-s\u0026rdquo; argument:\nunix\u0026gt; cat exploit.txt | ./hex2raw | ./bufbomb -u \u0026lt;userid\u0026gt; -s  The current results for each bomb are displayed on a Web \u0026ldquo;scoreboard.\u0026rdquo; As with the Bomb Lab there are no explicit handins and the lab is self-grading.\nThe autograding service consists of four user-level programs that run in the main ./buflab directory:\n  Request Server. Students download their bombs and display the scoreboard by pointing a browser at a simple HTTP server called the \u0026ldquo;request server.\u0026rdquo;\n  Result Server. Each time a student submits an exploit string the buffer bomb sends a short HTTP message, called an \u0026ldquo;autoresult string,\u0026rdquo; to an HTTP \u0026ldquo;result server,\u0026rdquo; which simply appends the autoresult string to a \u0026ldquo;scoreboard log file.\u0026rdquo;\n  Report Daemon. The \u0026ldquo;report daemon\u0026rdquo; periodically scans the scoreboard log file. The report daemon finds the most recent exploit string submitted by each student for each phase, and validates these strings by applying them to a local copy of the buffer bomb (unlike the Bomb Lab, each student works on the same buffer bomb). It then updates the HTML scoreboard that summarizes phases that have been successfully solved for each bomb (identified by cookie to protect the student privacy), rank ordered by the number of solved levels.\n  To avoid infinite loops during validation, the Report Daemon calls each bufbomb in autograding mode, using the -g flag. This causes the bomb to timeout after 5 seconds.\n Main daemon. The \u0026ldquo;main daemon\u0026rdquo; starts and nannies the request server, result server, and report deamon, ensuring that exactly one of these processes (and itself) is running at any point in time. If one of these processes dies for some reason, the main daemon detects this and automatically restarts it. The main daemon is the only program you actually need to run.  2. Files #  The ./buflab directory contains the following files:\n Makefile - For starting/stopping the lab and cleaning files buflab-handout/ - Contains the files handed out to each student buflab.pl* - Main daemon that nannies the other servers \u0026amp; daemons Buflab.pm - Buflab configuration file buflab-reportd.pl* - Report daemon that continuously updates scoreboard buflab-requestd.pl* - Request server that serves bombs to students buflab-resultd.pl* - Result server that gets autoresult strings from bombs buflab-scoreboard.html - Real-time Web scoreboard buflab-update.pl* - Helper to buflab-reportd.pl that updates scoreboard handin/ - Most recent exploits from each student and each level log-status.txt - Status log with msgs from various servers and daemons log.txt - Scoreboard log of autoresults received from bombs makebomb.pl* - Program that builds a buffer bomb scores.txt - Summarizes current scoreboard scores for each student src/ - The buffer bomb source files, including a master - solver in ./src/solve the automatically generates - a solution string for any userid and level. writeup/ - Sample Latex Buffer Lab writeup  3. Buffer Bomb Terminology #  Notifying Bomb: A buffer bomb can be compiled with a NOTIFY option that allows the student to submit successful exploit strings to the autograding service. Such bombs are called \u0026ldquo;notifying bombs.\u0026rdquo;\nQuiet Bomb: A buffer bomb that is not a notifying bomb is called a \u0026ldquo;quiet bomb.\u0026rdquo;\nCookie: Unlike the Bomb Lab, each student works on the same binary. However, the solution to each phase is different for each student because the exploit string typically must contain a 32-bit \u0026ldquo;cookie\u0026rdquo; that is computed from the student\u0026rsquo;s userid.\n4. Offering the Buffer Lab #  As with the Bomb Lab, there are two basic flavors of the Buffer Lab: In the \u0026ldquo;online\u0026rdquo; version, the instructor uses the autograding service to handout buffer bombs to each student on demand (each student gets the same bomb program), and to automatically track their progress on the realtime scoreboard. In the \u0026ldquo;offline\u0026rdquo; version, the instructor builds, hands out, and grades the student bombs manually, without using the autograding service.\nWhile both versions give the students a rich experience, we recommend the online version. It is clearly the most compelling and fun for the students, and the easiest for the instructor to grade. However, it requires that you keep the autograding service running non-stop, because handouts, grading, and reporting occur continuously for the duration of the lab. We\u0026rsquo;ve made it very easy to run the service, but some instructors may be uncomfortable with this requirement and will opt instead for the offline version.\nHere are the directions for offering both versions of the lab.\n4.1. Create a Buffer Lab Directory #  Identify the generic Linux machine ($SERVER_NAME) where you will create the Buffer Lab directory (./buflab) and, if you are offering the online version, run the autograding service. You\u0026rsquo;ll only need a user account on this machine. You don\u0026rsquo;t need root access. Any desktop with an internet connection will do.\nEach offering of the Buffer Lab starts with a clean new ./buflab directory on $SERVER_NAME. For example:\nlinux\u0026gt; tar xvf buflab.tar linux\u0026gt; cd buflab linux\u0026gt; make cleanallfiles  4.2 Configure the Buffer Lab #  Configure the Buffer Lab by editing the following file:\n./Buflab.pm - This is the main configuration file. You will only need to modify or inspect a few variables in Section 1 of this file. Each variable is preceded by a descriptive comment. If you are offering the offline version, you can ignore all of these settings.\nIf you are offering the online version, you will also need to edit the following file:\n./src/config.h - This file lists the domain names of the hosts that notifying bombs are allowed to submit results from. Make sure you update this correctly, else you and your students won\u0026rsquo;t be able to submit their results. You should include $SERVER_NAME in this list, along with any machines that your students will be submitting from.\n4.3. Update the Lab Writeup #  Once you have updated the configuration files, modify the Latex lab writeup in ./writeup/buflab.tex for your environment. Then type the following in the ./writeup directory:\nunix\u0026gt; make clean unix\u0026gt; make  This will create ps and pdf versions of the writeup\n4.4. Running the Online Buffer Lab #  4.4.1. Short Version #  From the ./buflab directory:\n(1) Reset the Buffer Lab from scratch by typing linux\u0026gt; make cleanallfiles\n(2) Start the autograding service by typing linux\u0026gt; make start\n(3) Stop the autograding service by typing linux\u0026gt; make stop\nYou can start and stop the autograding service as often as you like without losing any information. When in doubt \u0026ldquo;make stop; make start\u0026rdquo; will get everything in a stable state.\nHowever, resetting the lab (\u0026ldquo;make cleanallfiles\u0026rdquo;) deletes all handin strings, status logs, and the scoreboard log. Do this only during debugging, or the very first time you start the lab for your students.\nThe ./src/solve directory contains a master solver script called ./solve.pl that you can use to automatically generate a nicely commented solution exploit string for any userid and phase. See ./src/solve/README for details.\nThe ./handin directory contains the most recent exploit string received from each userid and each phase\n\u0026lt;userid\u0026gt;-\u0026lt;level\u0026gt;-exploit.txt  as well as a report showing the result from the validation\n\u0026lt;userid\u0026gt;-\u0026lt;level\u0026gt;-report.txt  Students request bombs by pointing their browsers at http://$SERVER_NAME:$REQUESTD_PORT/\nStudents submit their successful exploit strings to the grading service by calling the bufbomb with the -s option:\nlinux\u0026gt; cat exploit_string | ./hex2raw | ./bufbomb -u bovik -s  Students view the scoreboard by pointing their browsers at http://$SERVER_NAME:$REQUESTD_PORT/scoreboard\n4.4.2. Long Version #  (1) Resetting the Buffer Lab. \u0026ldquo;make cleanallfiles\u0026rdquo; resets the lab from scratch, deleting all data specific to a particular instance of the lab, such as the status log, the scoreboard log, and the handin file. Do this when you\u0026rsquo;re ready for the lab to go \u0026ldquo;live\u0026rdquo; to the students.\nResetting is also useful while you\u0026rsquo;re preparing the lab. Before the lab goes live, you\u0026rsquo;ll want to request a few bombs for yourself, run them, defuse a few phases, explode a few phases, and make sure that the results are displayed properly on the scoreboard. If there is a problem (say because you forgot to update the list of machines the bombs are allowed to run in src/config.h) you can fix the configuration, reset the lab, and then request and run more test bombs.\nCAUTION: If you reset the lab after it\u0026rsquo;s live, you\u0026rsquo;ll lose all your records of the students handins. You\u0026rsquo;ll have to ask them to submit their results again.\n(2) Starting the Buffer Lab. \u0026ldquo;make start\u0026rdquo; runs buflab.pl, the main daemon that starts and nannies the other programs in the service, checking their status every few seconds and restarting them if necessary:\n(3) Stopping the Buffer Lab. \u0026ldquo;make stop\u0026rdquo; kills all of the running servers. You can start and stop the autograding service as often as you like without losing any information. When in doubt \u0026ldquo;make stop; make start\u0026rdquo; will get everything in a stable state.\nRequest Server: The request server is a simple special-purpose HTTP server that (1) builds and delivers buffer bombs to student browsers on demand, and (2) displays the current state of the real-time scoreboard.\nA student requests a bomb from the request daemon by pointing their favorite browser at\nhttp://$SERVER_NAME:$REQUESTD_PORT/  The request server makes the buflab-handout directory (if necessary), tars it up, and delivers the tar file to the browser. The student then saves the tar file to disk. When the student untars this file, it creates a directory (./buflab-handout) with the following three binary files:\nbufbomb* Notifying custom bomb executable hex2raw* Converts a hex-encoded exploit string to a byte stream makecookie* Computes the cookie associated with a userid.  The request server also makes sure that there are bufbomb, hex2raw, and makecookie binaries in the ./buflab/src directory.\nResult Server: Each time a student submits an exploit string, the buffer bomb sends an HTTP \u0026ldquo;autoresult string\u0026rdquo; to the result server, which then appends the message to the scoreboard log. Each autoresult string contains the userid, level, and exploit string.\nReport Daemon: The report daemon periodically scans the scoreboard log (log.txt) and updates the scoreboard (buflab-scoreboard.txt). For each userid, it validates the most recently received exploit string, and updates the scoreboard. The update frequency is a configuration variable in Buflab.pm.\nInstructors and students view the scoreboard by pointing their browsers at:\nhttp://$SERVER_NAME:$REQUESTD_PORT/scoreboard  4.4.3. Grading the Online Buffer Lab #  The online Buffer Lab is self-grading. At any point in time, the tab-delimited file \u0026ldquo;./buflab/scores.txt\u0026rdquo; contains the most recent scores for each student. This file is created by the report daemon each time it generates a new scoreboard.\nThe autograding service also updates the ./buflab/handin directory, which contains information that will be very helpful to you when students have questions about their submissions, especially when they submit solutions that passed their bufbomb but failed when evaluated by the grading server (common for the nitro phase).\nFor each student (userid), it keeps the last exploit string they submitted for each phase (0-4) in a file called\n\u0026lt;userid\u0026gt;-\u0026lt;level\u0026gt;-exploit.txt  along with a report file called\n\u0026lt;userid\u0026gt;-\u0026lt;level\u0026gt;-report.txt  that shows the output from the buffer bomb on the corresponding string.\nSection 5 describes how to generate solutions for arbitrary userids and levels.\n4.4.4. Additional Notes on the Online Buffer Lab #    If you want to build your own notifying bomb and hand it out manually to your students (rather than having them use the request server), then you should use the \u0026ldquo;./makebomb.pl\u0026rdquo; script:\nunix\u0026gt; ./makebomb.pl -n\nThis creates the three binaries, ./src/bufbomb, ./src/hex2raw, and ./src/makecookie, and copies them to ./buflab-handout/, which you can then tar up and hand out to students.\n  All of the servers and daemons are stateless, so you can stop (\u0026ldquo;make stop\u0026rdquo;) and start (\u0026ldquo;make start\u0026rdquo;) the lab as many times as you like without any ill effects. If you accidentally kill one of the daemons, or you modify a daemon, or the daemon dies for some reason, then use \u0026ldquo;make stop\u0026rdquo; to clean up, and then restart with \u0026ldquo;make start\u0026rdquo;. If your Linux box crashes or reboots, simply restart the daemons with \u0026ldquo;make start\u0026rdquo;.\n  Information and error messages from the servers are appended to the status log in buflab/log-status.txt. Servers run quietly, so they can be started from initrc scripts at boot time.\n  Before going live with the students, we like to check everything out by running some tests. We do this by typing\nlinux\u0026gt; make cleanallfiles\nlinux\u0026gt; make start\n  Then we request a buffer bomb for ourselves by pointing a Web browser at\nhttp://$SERVER_NAME:$REQUESTD_PORT  After saving our bomb to disk, we untar it, copy it to a host in the approved list in src/config.h, and then solve and submit different phases for different fake userids to make sure that they are properly recorded on the scoreboard, which we check at\nhttp://$SERVER_NAME:$REQUESTD_PORT/scoreboard  Once we\u0026rsquo;re satisfied that everything is OK, we stop the lab\nlinux\u0026gt; make stop  and then go live:\nlinux\u0026gt; make cleanallfiles linux\u0026gt; make start  Once we go live, we type \u0026ldquo;make stop\u0026rdquo; and \u0026ldquo;make start\u0026rdquo; as often as we need to, but we are careful never to type \u0026ldquo;make cleanallfiles\u0026rdquo; again.\n4.5. Running the Offline Buffer Lab #  In this version of the lab, you build your own quiet buffer bombs manually and then hand them out to the students. The students work on solving their bombs offline (i.e., independently of any autograding service) and then handin their exploit strings for each phase to you, which you then grade manually.\nUse the ./makebomb.pl script to build the quiet buffer bomb:\nunix\u0026gt; ./makebomb.pl  This creates the three binaries ./src/bufbomb, ./src/hex2raw, and ./src/makecookie, and copies them to the ./buflab-handout/ directory, which you can then tar up and hand out to students.\nThe students will handin their solution files, which you can validate manually by feeding to the bomb:\nunix\u0026gt; cd src unix\u0026gt; cat \u0026lt;userid\u0026gt;-\u0026lt;level\u0026gt;.txt | ./hex2raw | ./bufbomb  "},{"id":7,"href":"/uni/docs/books/computer_systems_app/labs/cache/","title":"Cache","section":"Labs","content":"Cache Lab #   Note: This lab must be run on a 64-bit x86-64 system.\n Contents #   Files downloaded from CS:APP website as cachelab-handout.tar, and listed below in the original README contents  Lab Assignment Write-Up #  csapp.cs.cmu.edu/3e/cachelab.pdf.\nThis write-up is pretty helpful for even those doing self-study. Read through it to learn how to approach this lab\u0026rsquo;s problem.\nOriginal README.md #  This section is copied from csapp.cs.cmu.edu/3e/README-cachelab. It was modified only to conform to standard Markdown formatting.\nIt is not particularly useful for people doing self-study, but is reproduced here anyway.\n ##################################################################### # CS:APP Cache Lab # Directions to Instructors # # Copyright (c) 2013, R. Bryant and D. O'Hallaron, All rights reserved. ###################################################################### This directory contains the files that you will need to run the CS:APP cache lab, which develops the student\u0026rsquo;s understanding of caches.\n1. Overview #  In this lab, the student works on two C files called csim.c and trans.c. There are two parts: Part (a) involves implementing a cache simulator in csim.c. Part (b) involves writing a function that computes the transpose of a given matrix in trans.c, with the goal of minimizing the number misses on a simulated cache.\nEach time a student with login \u0026ldquo;foo\u0026rdquo; compiles their work, the Makefile automatically generates a handin file, called foo-handin.tar, that contains the csim.c and trans.c file. Students hand this tar file in to the instructor.\nThe driver program (driver.py) evaluates the correctness of the cache simulator in csim.c, and the performance and correctness of the transpose functions in trans.c. See the writeup for details.\nRequirements:\n The lab must be done on a 64-bit x86-64 system. The driver requires a version of Valgrind (http://valgrind.org) that supports the \u0026ldquo;\u0026ndash;tool=lackey\u0026rdquo; option.  2. Files #   Makefile Builds the entire lab README This file grade/ Autograding scripts for the instructor src/ Source code of this lab cachelab-handout/ Handout directory that goes to the students. This directory is completely generated from files in the src directory Never put any hard state in this directory. cachelab-handout.tar Tar file of handout directory that goes out to the students. writeup/ Latex writeup about the lab. Modify to reflect your environment.  3. Building the Lab #  To build the default version of the lab, modify the Latex lab writeup in ./writeup/cachelab.tex for your environment. Then type the following in the current directory:\n unix\u0026gt; make clean unix\u0026gt; make  This will build the cachelab-handout/ directory and its cachelab-handout.tar archive that you can handout to students. The command:\nunix\u0026gt; make dist DEST=\u0026lt;DIR\u0026gt;  will copy the tarfile and copies of the writeup to directory , where the students can access it.\n4. Handing in the Lab #  Each time a student with login \u0026ldquo;foo\u0026rdquo; compiles their work, the Makefile automatically generates a handin file called foo-handin.tar. If you want to autograde the handins, collect all of the student handin tar files in the ./grade/handin directory.\n5. Autograding the Lab #  You can run the driver program manually on each student\u0026rsquo;s handin, or you can use the autograding scripts in ./grade to automatically grade each of the .tar files in the handin/ directory.\nSee ./grade/README for instructions.\n"},{"id":8,"href":"/uni/docs/books/computer_systems_app/labs/data/","title":"Data","section":"Labs","content":"Data Lab #  This is likely the first lab students should do. Quoting from the assignment write-up, the \u0026ldquo;purpose of this assignment is to become more familiar with bit-level representations of integers and floating point numbers.\u0026rdquo; Chapter Two is the chapter concerned with this area.\nContents #   Files downloaded from CS:APP website as datalab-handout.tar, and listed below in the original README contents  Lab Assignment Write-Up #  csapp.cs.cmu.edu/3e/datalab.pdf.\nThis write-up is very helpful for even those doing self-study. Read through it to learn how to approach this lab\u0026rsquo;s problem(s).\nOriginal README.md #  *********************** The CS:APP Data Lab Directions to Students *********************** Your goal is to modify your copy of bits.c so that it passes all the tests in btest without violating any of the coding guidelines.\n0. Files: #   Makefile\t- Makes btest, fshow, and ishow README\t- This file bits.c\t- The file you will be modifying and handing in bits.h\t- Header file btest.c\t- The main btest program  btest.h\t- Used to build btest decl.c\t- Used to build btest tests.c - Used to build btest tests-header.c - Used to build btest   dlc*\t- Rule checking compiler binary (data lab compiler) driver.pl*\t- Driver program that uses btest and dlc to autograde bits.c Driverhdrs.pm - Header file for optional \u0026ldquo;Beat the Prof\u0026rdquo; contest fshow.c\t- Utility for examining floating-point representations ishow.c\t- Utility for examining integer representations  1. Modifying bits.c and checking it for compliance with dlc #  IMPORTANT: Carefully read the instructions in the bits.c file before you start. These give the coding rules that you will need to follow if you want full credit.\nUse the dlc compiler (./dlc) to automatically check your version of bits.c for compliance with the coding guidelines:\n unix\u0026gt; ./dlc bits.c  dlc returns silently if there are no problems with your code. Otherwise it prints messages that flag any problems. Running dlc with the -e switch:\n unix\u0026gt; ./dlc -e bits.c  causes dlc to print counts of the number of operators used by each function.\nOnce you have a legal solution, you can test it for correctness using the ./btest program.\n2. Testing with btest #  The Makefile in this directory compiles your version of bits.c with additional code to create a program (or test harness) named btest.\nTo compile and run the btest program, type:\nunix\u0026gt; make btest unix\u0026gt; ./btest [optional cmd line args]  You will need to recompile btest each time you change your bits.c program. When moving from one platform to another, you will want to get rid of the old version of btest and generate a new one. Use the commands:\nunix\u0026gt; make clean unix\u0026gt; make btest  Btest tests your code for correctness by running millions of test cases on each function. It tests wide swaths around well known corner cases such as Tmin and zero for integer puzzles, and zero, inf, and the boundary between denormalized and normalized numbers for floating point puzzles. When btest detects an error in one of your functions, it prints out the test that failed, the incorrect result, and the expected result, and then terminates the testing for that function.\nHere are the command line options for btest:\nunix\u0026gt; ./btest -h Usage: ./btest [-hg] [-r \u0026lt;n\u0026gt;] [-f \u0026lt;name\u0026gt; [-1|-2|-3 \u0026lt;val\u0026gt;]*] [-T \u0026lt;time limit\u0026gt;] -1 \u0026lt;val\u0026gt; Specify first function argument -2 \u0026lt;val\u0026gt; Specify second function argument -3 \u0026lt;val\u0026gt; Specify third function argument -f \u0026lt;name\u0026gt; Test only the named function -g Format output for autograding with no error messages -h Print this message -r \u0026lt;n\u0026gt; Give uniform weight of n for all problems -T \u0026lt;lim\u0026gt; Set timeout limit to lim Examples:\nTest all functions for correctness and print out error messages: unix\u0026gt; ./btest\nTest all functions in a compact form with no error messages: unix\u0026gt; ./btest -g\nTest function foo for correctness: unix\u0026gt; ./btest -f foo\nTest function foo for correctness with specific arguments: unix\u0026gt; ./btest -f foo -1 27 -2 0xf\nBtest does not check your code for compliance with the coding guidelines. Use dlc to do that.\n3. Helper Programs #  We have included the ishow and fshow programs to help you decipher integer and floating point representations respectively. Each takes a single decimal or hex number as an argument. To build them type:\nunix\u0026gt; make  Example usages:\nunix\u0026gt; ./ishow 0x27 Hex = 0x00000027,\tSigned = 39,\tUnsigned = 39 unix\u0026gt; ./ishow 27 Hex = 0x0000001b,\tSigned = 27,\tUnsigned = 27 unix\u0026gt; ./fshow 0x15213243 Floating point value 3.255334057e-26 Bit Representation 0x15213243, sign = 0, exponent = 0x2a, fraction = 0x213243 Normalized. +1.2593463659 X 2^(-85) linux\u0026gt; ./fshow 15213243 Floating point value 2.131829405e-38 Bit Representation 0x00e822bb, sign = 0, exponent = 0x01, fraction = 0x6822bb Normalized. +1.8135598898 X 2^(-126)  "},{"id":9,"href":"/uni/docs/books/computer_systems_app/labs/malloc/","title":"Malloc","section":"Labs","content":"Malloc Lab #   üëãÔ∏è Note: Updated to Y86-64 for CS:APP3e. Students are given a small default Y86-64 array copying function and a working pipelined Y86-64 processor design that runs the copy function in some nominal number of clock cycles per array element (CPE). The students attempt to minimize the CPE by modifying both the function and the processor design. This gives the students a deep appreciation for the interactions between hardware and software.\n  Note: The lab materials include the master source distribution of the Y86-64 processor simulators and the Y86-64 Guide to Simulators. (I unzipped it into tar/)\n Contents #   Files downloaded from CS:APP website as archlab-handout.tar, and listed below in the original README contents  Lab Assignment Write-Up #  csapp.cs.cmu.edu/3e/malloclab.pdf.\nThis write-up is pretty helpful for even those doing self-study. Read through it to learn how to approach this lab\u0026rsquo;s problem.\nOriginal README.md #  This section is copied from csapp.cs.cmu.edu/3e/README-archlab. It was modified only to conform to standard Markdown formatting.\nIt is not particularly useful for people doing self-study, but is reproduced here anyway.\n ##################################################################### # CS:APP Malloc Lab # Directions to Instructors # # Copyright (c) 2002, R. Bryant and D. O'Hallaron, All rights reserved. # May not be used, modified, or copied without permission. # ###################################################################### This directory contains the files that you will need to run the CS:APP malloc lab, which develops a student\u0026rsquo;s understanding of pointers, system-level programming, and memory managment.\n1. Overview #  In this lab, students write their own storage allocator, in particular implementations of the malloc, free, and realloc functions. A trace-driven driver (mdriver) evaluates the quality of the student\u0026rsquo;s implementation in terms of space utilization and throughput.\n2. Files #   Makefile\tMakefile that builds the Lab README\tThis file grade/\tAutograding scripts malloclab-handout/\tThe files handed out to the students src/\tThe driver sources traces/\tThe malloc/free/realloc trace files used by the driver writeup/\tThe malloc lab writeup  3. Building the Lab #  Step 1: Configure the driver in src/ for your site. See src/README for detailed information on the driver.\nStep 2: Modify the Latex writeup in writeup/ to reflect the handout and handin directions for your site. If you don\u0026rsquo;t use Latex, use your favorite document preparation system to prepare Postcript and PDF versions of the writeup in malloclab.ps and malloclab.pdf.\nStep 3: Modify the LABNAME and DEST variables in ./Makefile for your site.\nStep 4: Type \u0026ldquo;make\u0026rdquo; to build the $(LABNAME)-handout.tar file.\nStep 5: Type \u0026ldquo;make dist\u0026rdquo; to copy the $(LABNAME)-handout.tar file and the writeup to the distribution directory where the students will retrieve the lab.\n4. Grading the Lab #  There are autograding scripts for this lab. See grade/README for details.\n"},{"id":10,"href":"/uni/docs/books/computer_systems_app/labs/performance/","title":"Performance","section":"Labs","content":"Performance Lab #  Contents #   Files downloaded from CS:APP website as perflab-handout.tar, and listed below in the original README contents  Lab Assignment Write-Up #  csapp.cs.cmu.edu/3e/perflab.pdf.\nThis write-up is pretty helpful for even those doing self-study. Read through it to learn how to approach this lab\u0026rsquo;s problem.\nOriginal README.md #  This section is copied from csapp.cs.cmu.edu/3e/README-archlab. It was modified only to conform to standard Markdown formatting.\nIt is not particularly useful for people doing self-study, but is reproduced here anyway.\n ##################################################################### # CS:APP Performance Lab # Directions to Instructors # # Copyright (c) 2002, R. Bryant and D. O'Hallaron, All rights reserved. # May not be used, modified, or copied without permission. # ###################################################################### This directory contains the files that you will need to run the CS:APP Performance Lab, which develops the students\u0026rsquo;s understanding of the performance impact of caches and code optimizations such as blocking and loop unrolling.\n1. Overview #  In this lab, students work on a C file, called kernels.c, that contains some image processing kernels. The students are asked to use the concepts they have learned in class to make these kernels run as fast as possible.\nStudents evaluate the performance of their kernels by linking kernels.c into a driver program called driver.c. Students can register different versions of their kernel functions with the driver. When the driver runs, it will execute, measure, and report on the performance of each registered function. This is a very useful versioning feature that allows students try out different approaches and do side by side comparisons.\nYou should strongly encourage your students to take advantage of this versioning feature in the driver.\n2. Files #   Makefile\tBuilds the entire lab README\tThis file src/\tDriver code that runs and measures solutions perflab-handout/\tHandout directory that goes to the students grade/\tAutograder code writeup/\tSample Latex lab writeup  3. Building the Lab #  To build the lab, modify the Latex lab writeup in ./writeup/perflab.tex for your environment. Then type the following in the current directory:\nunix\u0026gt; make clean unix\u0026gt; make  The Makefile generates the driver code, formats the lab writeup, and then copies the driver code to the perflab-handout directory. Finally, it builds a tarfile of the perflab-handout directory (in perflab-handout.tar) which you can distribute to students. The command:\nunix\u0026gt; make dist DEST=\u0026lt;DIR\u0026gt;  will copy the tarfile and copies of the writeup to directory , where the students can access it.\n4. Autograding the Lab #  There is an autograding script that automatically grades the lab. See ./grade/README for instructions.\n"},{"id":11,"href":"/uni/docs/books/computer_systems_app/labs/proxy/","title":"Proxy","section":"Labs","content":"Proxy Lab #  Contents #   Files downloaded from CS:APP website as proxylab-handout.tar, and listed below in the original README contents  Lab Assignment Write-Up #  csapp.cs.cmu.edu/3e/proxylab.pdf.\nThis write-up is pretty helpful for even those doing self-study. Read through it to learn how to approach this lab\u0026rsquo;s problem.\nOriginal README.md #  This section is copied from csapp.cs.cmu.edu/3e/README-proxylab. It was modified only to conform to standard Markdown formatting.\nIt is not particularly useful for people doing self-study, but is reproduced here anyway.\n #####################################################################\nCS:APP Proxy Lab #  Directions to Instructors #  #  Copyright (c) 2004-2016, R. Bryant and D. O\u0026rsquo;Hallaron, All rights reserved. #  ######################################################################\n1. Overview #  In this lab, students build a simple concurrent caching Web proxy that accepts HTTP 1.0 requests from clients, forwards them to end servers, and then sends the replies back to the clients. The proxy caches objects returned by the end servers, and attempts to satisfy requests from clients from the cache before forwarding the requests to the end servers.\n2. Files #   Makefile Builds the entire lab README This file proxylab-handout/ Handout directory that goes to the students. Regenerated from src/ src/ Source code for the solution and the driver writeup/ Latex lab writeup grade/ Grading directory where instructors/TAs run the autograder  3. Building the Lab #  Step 1: Modify the Latex writeup in writeup to reflect the handout and handin instructions for your site.\nStep 2: Type \u0026ldquo;make clean; make\u0026rdquo; to format the writeup in writeup/proxylab.pdf and to build the proxylab-handout.tar file.\nStep 3: Distribute proxylab.pdf and proxylab-handout.tar to the students.\n4. Grading the Lab #  Autograding scripts are available in the grade/ directory. See grade/README for details.\nWhen we offer this lab at CMU, we do some additional manual grading:\n Manually test on four real sites (see writeup/proxylab.tex for details) Manually grade for Style Manually check for errors that the autograder doesn\u0026rsquo;t check for, such as race conditions on shared data structures.  5. Solutions #  The reference solution is in ./src/proxy.[ch] and ./src/cache.[ch]\n"},{"id":12,"href":"/uni/docs/books/computer_systems_app/labs/shell/","title":"Shell","section":"Labs","content":"Shell Lab #  Contents #   Files downloaded from CS:APP website as shlab-handout.tar, and listed below in the original README contents  Lab Assignment Write-Up #  csapp.cs.cmu.edu/3e/shlab.pdf.\nThis write-up is pretty helpful for even those doing self-study. Read through it to learn how to approach this lab\u0026rsquo;s problem.\nOriginal README.md #  This section is copied from csapp.cs.cmu.edu/3e/README-shlab. It was modified only to conform to standard Markdown formatting.\nIt is not particularly useful for people doing self-study, but is reproduced here anyway.\n ##################################################################### # CS:APP Shell Lab # Directions to Instructors # # Copyright (c) 2002, R. Bryant and D. O'Hallaron, All rights reserved. # May not be used, modified, or copied without permission. # ###################################################################### This directory contains the files that you will need to run the CS:APP shell lab. The lab is the student\u0026rsquo;s first experience with systems-level programming, and teaches them about processes, process control, and signals.\n1. Overview #  In this lab, students build a simple Unix shell with job control. They are given a skeleton called tsh.c (Tiny Shell) that implements some of the less interesting functions, and are then asked to implement the functions and signal handlers that provide job control.\nStudents evaluate the functionality of their shells using a trace-driven driver program called sdriver.pl.\nThe reference solution is in ./src/tsh.c\n2. Files #   README grade/\tAutograding scripts shlab-handout/\tHandout directory that is given to the students src/\tTrace-driven driver program writeup/\tSample Latex lab writeup  3. Building the Lab #  To build the lab, modify the Latex lab writeup in ./writeup/shlab.tex for your environment. Then type the following in the current directory:\nunix\u0026gt; make clean unix\u0026gt; make  The Makefile generates the driver code, formats the lab writeup, and then copies the driver code to the shlab-handout directory. Finally, it builds a tarfile of the shlab-handout directory (in shlab-handout.tar) which you can distribute to students. The command:\nunix\u0026gt; make dist DEST=\u0026lt;DIR\u0026gt;  will copy the tarfile and copies of the writeup to directory , where the students can access it.\n4. Autograding the Lab #  There is an autograding script that automatically grades the lab. See ./grade/README for instructions.\n"},{"id":13,"href":"/uni/docs/books/crafting_interpreters/","title":"Crafting Interpreters","section":"Books","content":"Crafting Interpreters #   by Robert Nystrom (@munificentbob)\n I worked on the 1st Print Edition. Unlike a lot of the other books worked on in this monorepo, the code doesn\u0026rsquo;t follow a chapter-by-chapter structure, as it\u0026rsquo;s not appropriate in this case.\nThis book covers off two implementations of a programming language called Lox, and each gets its own folder.\n jlox (Java Implementation) clox (C Implementation)  Textbook code is available at https://github.com/munificent/craftinginterpreters/.\njlox #  Usage #  At the moment all my JLox implementation can do is scan/lex Lox and print out the tokens.\nYou can run the jlox exe in \u0026lsquo;repl\u0026rsquo; mode:\nbazel run //books/crafting_interpreters/jlox/lox:Lox \u0026gt; var foo = 12; VAR var null IDENTIFIER foo null EQUAL = null NUMBER 123 123.0 SEMICOLON ; null EOF null Or you can pass it a file:\nbazel run //books/crafting_interpreters/jlox/lox:Lox -- foo.lox "},{"id":14,"href":"/uni/docs/books/data_science_from_scratch/2_a_crash_course_in_python/","title":"2 a Crash Course in Python","section":"Data Science From Scratch","content":"I skipped this chapter because I already know Python well enough.\n"},{"id":15,"href":"/uni/docs/books/data_science_from_scratch/","title":"Data Science From Scratch","section":"Books","content":"Data Science from Scratch #   First Principles with Python\n Chapters #   Introduction A Crash Course In Python Visualizing Data Linear Algebra Statistics Probabilty Hypothesis and Inference Gradient Descent Getting Data Working With Data Machine Learning K-Nearest Neighbours Naive Bayes Simple Linear Regression Multiple Regression Logistic Regression Decision Trees Neural Networks Deep Learning Clustering Natural Language Processing Network Analysis Recommender Systems Databases and SQL MapReduce Data Ethics (No coding) Go Forth and Do Data Science (No coding)  "},{"id":16,"href":"/uni/docs/books/fp_in_scala/","title":"Fp in Scala","section":"Books","content":"Functional Programming in Scala #   \u0026lsquo;The Red Book\u0026rsquo;\n I worked on the 1st Edition. The 2nd Edition is supposed to come out late 2021 or in 2022, I think.\nTextbook code and answer hints are available at https://github.com/fpinscala/fpinscala.\n"},{"id":17,"href":"/uni/docs/books/programming_rust/","title":"Programming Rust","section":"Books","content":"Programming Rust #   Fast, Safe Systems Development\n I worked on the 2nd Edition.\nTextbook code is available at https://github.com/ProgrammingRust.\n"},{"id":18,"href":"/uni/docs/books/the_rust_programming_language/","title":"The Rust Programming Language","section":"Books","content":"The Rust Programming Language #   \u0026ldquo;the book\u0026rdquo;\n Working through the book to re-introduce myself to Rust, but using Bazel\u0026rsquo;s rules_rust alongside the standard Cargo build \u0026amp; packaging system.\n"},{"id":19,"href":"/uni/docs/concurrency/","title":"Concurrency","section":"Docs","content":"Concurrency #  "},{"id":20,"href":"/uni/docs/databases/fromscratch_heapfile_and_hashindex/","title":"Fromscratch Heapfile and Hashindex","section":"Databases","content":"From scratch Heap file and Hash index #   Originally written for some undergraduate DB systems class I took.\n This is still a bit interesting to me as it\u0026rsquo;s a from-scratch implementation of part of a DB and I think it would be a good exercise to revisit this code and fix the bugs that are definitely in there somewhere.\nWill be funny to see how bad the Java code is too.\nUsage #  The dataset used in this project is available at https://data.gov.au/data/dataset/asic-business-names but I\u0026rsquo;ve also copied a subset of that dataset into ./data/\ndbload #  Implementing a heap file in Java. Load a database relation (.tsv) and write a heap file.\nbazel run //databases/fromscratch_heapfile_and_hashindex:dbload -- \\  -p 4096 \\  \u0026#34;$(git rev-parse --show-toplevel)/databases/fromscratch_heapfile_and_hashindex/data/TRUNCATED_DATASET_WO_HEADER.csv\u0026#34; hashload #  A hash indexer that uses the heap file to build an index, hash.\u0026lt;pagesize\u0026gt;.\ndbquery #  Perform a text search using the heap file, with or without an index.\nBuild #  bazel build //databases/fromscratch_heapfile_and_hashindex/...\nTests #  \u0026hellip; I guess tests weren\u0026rsquo;t part of the assignment.\n"},{"id":21,"href":"/uni/docs/databases/sql/","title":"SQL","section":"Databases","content":"SQL #  Playgrounds #   How can I cheaply and easily do exercises and experimentation when studying SQL?\n Google BigQuery #  I have a GCP project called public-uni to use BigQuery.\nPros\n Serverless, so very cheap when operating on small datasets in short bursts. Cloud Console UI  Cons:\n Doesn\u0026rsquo;t support column constraints. https://stackoverflow.com/a/42944926  Amazon Aurora Serverless #  TODO\n"},{"id":22,"href":"/uni/docs/machine_learning/applications/self_driving_toy_car/","title":"Self Driving Toy Car","section":"Applications","content":"Self-driving Toy Cars #  I have a Donkey Car S1, bought from www.robocarstore.com in September 2021.\nCommunity docs: https://docs.donkeycar.com/\nInstall code #  This is not using the monorepo\u0026rsquo;s Bazel build system at the moment. The donkeycar library doesn\u0026rsquo;t distribute a wheel, and I\u0026rsquo;m wary of installing it from source.\ncd \u0026#34;$(git rev-parse --show-toplevel)/machine_learning/applications/self_driving_toy_car\u0026#34; python3 -m venv .venv source .venv/bin/activate python3 -m pip install -r requirements.txt Development #  cd \u0026quot;$(git rev-parse --show-toplevel)/machine_learning/applications/self_driving_toy_car\u0026quot; source .venv/bin/activate Logging onto the Donkey Car #  I first had to go through this setup to get the Raspberry Pi available on my WiFi. Then it was just a matter of grabbing the IP address and running:\nssh pi@192.168.1.100 It prompts for a password, which for the pi user is raspberry (‚ö† security risk to leave default pw)Ô∏è.\nThe terminal looks like:\n(env) pi@donkey-c98b3c:~ $ Useful documentation #   Donkey Car S1, Getting Started Guide docs.donkeycar.com/  "},{"id":23,"href":"/uni/docs/machine_learning/applications/spam/a_plan_for_spam/","title":"A Plan for Spam","section":"Spam","content":"A Plan For Spam #   Self-education in end-to-end machine learning application engineering, based off Paul Graham\u0026rsquo;s early 2000s essay.\n Rules #  This code is for education, both of myself and others who care to engage with it. As such, it has understanding-oriented rules.\n \u0026lsquo;From scratch\u0026rsquo;. No 3rd-party libraries or frameworks (stdlib OK). Write a basic version of what\u0026rsquo;s needed. Run locally. Let\u0026rsquo;s avoid the pain and added complexity of Docker, Kubernetes, AWS, etc. End-to-end, deliver business value. Don\u0026rsquo;t build only the model. The model is not an application.  Business Problem #  Spam.\nSystem overview #   Components, and how they connect.\n Components #   Mail server (incoming / outgoing) Spam detection API server Email user activity simulation server Data warehouse Model trainer  Diagram #  TODO\nUsage #  python3 agent.py start\nWill open multiple terminal windows running the various parts of the system.\nBe aware, they may open up all on top of each other, making it look like just one opened.\nDevelopment #  Testing #  The application code is all pure-Python (stdlib only), but testing uses pytest.\nTODO\nType-checking #  At the moment, I haven\u0026rsquo;t got a virtualenv so mypy is installed to system. ü§Æ\nmypy --namespace-packages *.py\n"},{"id":24,"href":"/uni/docs/machine_learning/applications/spam/a_plan_for_spam/datasets/","title":"Datasets","section":"A Plan for Spam","content":"List of public Spam datasets in section 4.2 of https://www.baeldung.com/cs/spam-filter-training-sets\n"},{"id":25,"href":"/uni/docs/operating_systems/linux/strace_in_seventy_lines/","title":"Strace in Seventy Lines","section":"Linux","content":"ministrace #  ministrace is a small strace implementation by Nelson Elhage (@nelhage).\nministrace is a minimal implementation of strace originally about 70 lines of C. It isn\u0026rsquo;t nearly as functional as the real thing, but you can use it to learn most of what you need to know about the core interfaces it uses.\nministrace was written for a blog post, which explains in some detail how it works.\nUsage #  ministrace [-n \u0026lt;system call name\u0026gt;|-s \u0026lt;system call int\u0026gt;] \u0026lt;program\u0026gt; \u0026lt;program args\u0026gt;\nBasic ministrace usage just takes a command line:\nministrace \u0026lt;program\u0026gt; \u0026lt;program args\u0026gt;\nThis will run the program provided with the given arguments, and print out a sequence of all the system calls which made by the program.\nBuild with Bazel #  (Only on Linux)\nbazel build //operating_systems/linux/strace_in_seventy_lines:minitrace\nand run:\nbazel run //operating_systems/linux/strace_in_seventy_lines:minitrace -- python -c \u0026quot;print('hello world')\u0026quot;\n"},{"id":26,"href":"/uni/docs/optimization/basic_neuralnet_lib/","title":"Basic Neuralnet Lib","section":"Optimization","content":"Basic Neural Network Library #  TODO\nDemo #  TODO - demo.py\nCredits #   JoelNet  "},{"id":27,"href":"/uni/docs/performance/","title":"Performance","section":"Docs","content":"Performance #  Section dedicated to learning about software performance in various languages, where \u0026lsquo;performance\u0026rsquo; is here understood to concern:\n Memory usage CPU usage Disk usage Network performance \u0026amp; usage Concurrency \u0026amp; throughput Latency  "},{"id":28,"href":"/uni/docs/performance/jvm/bytebuffer-allocatedirect/","title":"Bytebuffer Allocatedirect","section":"Jvm","content":"SerCe\u0026rsquo;s blog - Indirect Effects of Allocate Direct #   https://serce.me/posts/18-11-2020-allocate-direct/\n The original code is https://github.com/SerCeMan/allocatedirect/tree/a0b32ea9952bed040a738e3ed1746ff197d084c0.\nI modified the code to be built by Bazel not Gradle/Maven, and edited it to aid my understanding.\n"},{"id":29,"href":"/uni/docs/performance/napkin-math/","title":"Napkin Math","section":"Performance","content":"Napkin Math #   Originally from https://github.com/sirupsen/napkin-math.\n The goal of this project is to collect software, numbers, and techniques to quickly estimate the expected performance of systems from first-principles. For example, how quickly can you read 1 GB of memory? By composing these resources you should be able to answer interesting questions like: how much storage cost should you expect to pay for logging for an application with 100,000 RPS?\nThe best introduction to this skill is through my talk at SRECON.\nThe best way to practise napkin math in the grand domain of computers is to work on your own problems. The second-best is to subscribe to this newsletter where you\u0026rsquo;ll get a problem every few weeks to practise on. It should only take you a few minutes to solve each one as your facility with these techniques improve.\nThe archive of problems to practise with are here. The solution will be in the following newsletter.\nNumbers #  Below are numbers that are rounded from runs on a GCP c2-standard-4 (Intel Cascade) and 2017 Macbook (2.8GHz, quad-core).\nNote 1: Numbers have been rounded, which means they don\u0026rsquo;t line up perfectly. Note 2: Some throughput and latency numbers don\u0026rsquo;t line up (for ease of calculations see exact results e.g. here).\n   Operation Latency Throughput 1 MiB 1 GiB     Sequential Memory R/W (64 bytes) 5 ns 10 GiB/s 100 Œºs 100 ms   Hashing, not crypto-safe (64 bytes) 25 ns 2 GiB/s 500 Œºs 500 ms   Random Memory R/W (64 bytes) 50 ns 1 GiB/s 1 ms 1 s   Fast Serialization [8] [9] ‚Ä† N/A 1 GiB/s 1 ms 1s   Fast Deserialization [8] [9] ‚Ä† N/A 1 GiB/s 1 ms 1s   System Call 500 ns N/A N/A N/A   Hashing, crypto-safe (64 bytes) 500 ns 200 MiB/s 10 ms 10s   Sequential SSD read (8 KiB) 1 Œºs 4 GiB/s 200 Œºs 200 ms   Context Switch [1] [2] 10 Œºs N/A N/A N/A   Sequential SSD write, -fsync (8KiB) 10 Œºs 1 GiB/s 1 ms 1 s   TCP Echo Server (32 KiB) 10 Œºs 4 GiB/s 200 Œºs 200 ms   Sequential SSD write, +fsync (8KiB) 1 ms 10 MiB/s 100 ms 2 min   Sorting (64-bit integers) N/A 200 MiB/s 5 ms 5 s   Random SSD Seek (8 KiB) 100 Œºs 70 MiB/s 15 ms 15 s   Compression [3] N/A 100 MiB/s 10 ms 10s   Decompression [3] N/A 200 MiB/s 5 ms 5s   Serialization [8] [9] ‚Ä† N/A 100 MiB/s 10 ms 10s   Deserialization [8] [9] ‚Ä† N/A 100 MiB/s 10 ms 10s   Proxy: Envoy/ProxySQL/Nginx/HAProxy 50 Œºs ? ? ?   Network within same region [6] 250 Œºs 100 MiB/s 10 ms 10s   {MySQL, Memcached, Redis, ..} Query 500 Œºs ? ? ?   Random HDD Seek (8 KiB) 10 ms 70 MiB/s 15 ms 15 s   Network between regions [6] Varies 25 MiB/s 40 ms 40s   Network NA East \u0026lt;-\u0026gt; West 60 ms 25 MiB/s 40 ms 40s   Network EU West \u0026lt;-\u0026gt; NA East 80 ms 25 MiB/s 40 ms 40s   Network NA West \u0026lt;-\u0026gt; Singapore 180 ms 25 MiB/s 40 ms 40s   Network EU West \u0026lt;-\u0026gt; Singapore 160 ms 25 MiB/s 40 ms 40s    ‚Ä†: \u0026ldquo;Fast serialization/deserialization\u0026rdquo; is typically a simple wire-protocol that just dumps bytes, or a very efficient environment. Typically standard serialization such as e.g. JSON will be of the slower kind. We include both here as serialization/deserialization is a very, very broad topic with extremely different performance characteristics depending on data and implementation.\nYou can run this with RUSTFLAGS='-C target-cpu=native' cargo run --release -- --help. You won\u0026rsquo;t get the right numbers when you\u0026rsquo;re compiling in debug mode. You can help this project by adding new suites and filling out the blanks.\nI am aware of some inefficiencies in this suite. I intend to improve my skills in this area, in order to ensure the numbers are the upper-bound of performance you may be able to squeeze out in production. I find it highly unlikely any of them will be more than 2-3x off, which shouldn\u0026rsquo;t be a problem for most users.\nCost Numbers #  Approximate numbers that should be consistent between Cloud providers.\n   What Amount $ / Month $ / Hour     CPU 1 $10 $0.02   Memory 1 GB $1    SSD 1 GB $0.1    Disk 1 GB $0.01    S3, GCS, .. 1 GB $0.01    Network 1 GB $0.01     Compression Ratios #  This is sourced from a few sources. [3] [4] [5] Note that compression speeds (but generally not ratios) vary by an order of magnitude depending on the algorithm and the level of compression (which trades speed for compression).\nI typically ballpark that another x in compression ratio decreases performance by 10x. E.g. we can get a 2x ratio on English Wikipedia at ~200 MiB/s, and 3x at ~20MiB/s, and 4x at 1MB/s.\n   What Compression Ratio     HTML 2-3x   English 2-4x   Source Code 2-4x   Executables 2-3x   RPC 5-10x    Techniques #   Don\u0026rsquo;t overcomplicate. If you are basing your calculation on more than 6 assumptions, you\u0026rsquo;re likely making it harder than it should be. Keep the units. They\u0026rsquo;re good checksumming. Wolframalpha has terrific support if you need a hand in converting e.g. KiB to TiB. Calculate with exponents. A lot of back-of-the-envelope calculations are done with just coefficients and exponents, e.g. c * 10^e. Your goal is to get within an order of magnitude right\u0026ndash;that\u0026rsquo;s just e. c matters a lot less. Only worrying about single-digit coefficients and exponents makes it much easier on a napkin (not to speak of all the zeros you avoid writing). Perform Fermi decomposition. Write down things you can guess at until you can start to hint at an answer. When you want to know the cost of storage for logging, you\u0026rsquo;re going to want to know how big a log line is, how many of those you have per second, what that costs, and so on.  Resources #   [1]: https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/ [2]: https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html [3]: https://cran.r-project.org/web/packages/brotli/vignettes/brotli-2015-09-22.pdf [4]: https://github.com/google/snappy [5]: https://quixdb.github.io/squash-benchmark/ [6]: https://dl.acm.org/doi/10.1145/1879141.1879143 [7]: https://en.wikipedia.org/wiki/Hard_disk_drive_performance_characteristics#Seek_times_\u0026_characteristics [8]: https://github.com/simdjson/simdjson#performance-results [9]: https://github.com/protocolbuffers/protobuf/blob/master/docs/performance.md \u0026ldquo;How to get consistent results when benchmarking on Linux?\u0026quot;. Great compilation of various Kernel and CPU features to toggle for reliable bench-marking, e.g. CPU affinity, disabling turbo boost, etc. It also has resources on proper statistical methods for benchmarking. LLVM benchmarking tips. Similar to the above in terms of dedicating CPUs, disabling address space randomization, etc. Top-Down performance analysis methodology. Useful post about using toplev to find the bottlenecks. This is particularly useful for the benchmarking suite we have here, to ensure the programs are correctly written (I have not taken them through this yet, but plan to). Godbolt\u0026rsquo;s compiler explorer. Fantastic resource for comparing assembly between Rust and e.g. C with Clang/GCC. cargo-asm. Cargo extension to allow disassembling functions. Unfortunately the support for closure is a bit lacking, which requires some refactoring. It\u0026rsquo;s also very slow on even this simple program. Agner\u0026rsquo;s Assembly Guide. An excellent resource on writing optimum assembly, which will be useful to inspect the various functions for inefficiencies in our suite. Agner\u0026rsquo;s Instruction Tables. Thorough resource on the expected throughput for various instructions which is helpful to inspect the assembly. halobates.de. Useful resource for low-level performance by the author of toplev. Systems Performance (book). Fantastic book about analyzing system performance, finding bottlenecks, and understanding operating systems. io_uring. Best summary, it links to many resources. How Long Does It Takes To Make a Context Switch Integer Compression Comparisons Files are hard  "},{"id":30,"href":"/uni/docs/tools/build/bazel/rules_julia/","title":"Rules Julia","section":"Bazel","content":"rules_julia #   Bazel rules for the Julia programming language.\n Currently I\u0026rsquo;ve done nothing here, but hoping to in future develop a very basic MVP to run the Julia code I write in this repo.\n"},{"id":31,"href":"/uni/docs/tools/build/bazel/rules_nim/","title":"Rules Nim","section":"Bazel","content":"rules_nim #   üëë üåø üíö ‚Äî Nim-lang build rules for Bazel\n Overview #  Bazel is a tool for building and test software and can handle large, multi-language projects at Scale. This project defines core build rules for Nim-lang that can be used to build, test, and package Nim-lang projects.\nRules #   nim_library - coming soon nim_binary - WIP. Very basics working.  Getting Started #  TODO\n"},{"id":32,"href":"/uni/docs/tools/build/docs/technical-documentation-system/","title":"Technical Documentation System","section":"Docs","content":"technical-documentation-system    üëã ‚ö†Ô∏è This project is experimental, and I don\u0026rsquo;t intend for it to be adopted by others until I\u0026rsquo;ve validated its usefulness and sensibility.\n  This documentation system exists as an experiment in providing a few features that I am coming to believe help ensure great technical documentation:\n Code updates and any required changes to relevant documentation can be completed in one workflow, a pull request.  No jumping into Confluence once a pull request is merged.   Code in documentation should run. Any code shown in technical documentation has automated testing for compilation and format.  No copy-pasting code from docs and finding a referenced object has been removed/renamed or that there\u0026rsquo;s a missing semicolon.   Code in documentation should be tested. Any code functionality shown in technical documentation can be unit or integration tested.  No more forgetting to update documentation when you change the behaviour of your code.     Note: This documentation system is built to integrate with the Bazel build system. üíöüåø\n Usage #  This system acts a pre-processor, taking Markdown documentation files as input, converting special references to code targets into \u0026lsquo;materialised\u0026rsquo; code blocks and returning Markdown files as output.\nDuring pre-processing, the Bazel build system can also run tests and other checks on referenced code, as referenced code just a target in the build graph.\nTo provide this functionality, technical-documentation-system exposes the technical_documents Bazel rule:\ntechnical_documents( name = \u0026#34;doc_1\u0026#34;, inputs = [\u0026#34;hello-world.md\u0026#34;], references = [ \u0026#34;//foo/bar\u0026#34;, \u0026#34;//bee/boo:biz\u0026#34;, ], ) For detailed documentation of the rule, see: TODO.md.\nBasic Static Documentation Webserver. #  While the system is designed to be agnostic of the particular documentation framework used, a minimal \u0026lsquo;render and serve\u0026rsquo; engine is provided. It is exposed via the technical_documentation_website Bazel rule:\ntechnical_documentation_website( name = \u0026#34;all_docs\u0026#34;, srcs = { \u0026#34;//:doc_1\u0026#34;: \u0026#34;/foo\u0026#34; # \u0026lt;key = document\u0026gt; : \u0026lt;value = position in website\u0026#39;s doc-tree\u0026gt; } ) Use bazel run //path/to:all_docs to run the minimal document server at localhost:8000. üöÄ\nAny Markdown documents in //:doc_1 will be served under /foo/, eg. localhost/foo/getting-started.md.\nInstallation #   üëã NOTE: These installation instructions are only relevant once this code is moved to its own repo.\n The project has no dependencies, so it\u0026rsquo;s easy to install in your Bazel WORKSPACE:\ntech_docs_system_version = \u0026#34;\u0026lt;some git-sha\u0026gt;\u0026#34; http_archive( name = \u0026#34;technical_documentation_system\u0026#34;, sha256 = \u0026#34;\u0026#34;, strip_prefix = \u0026#34;technical-documentation-system-{version}\u0026#34;.format(version = tech_docs_system_version), url = \u0026#34;https://github.com/thundergolfer/technical-documentation-system/archive/{version}.tar.gz\u0026#34;.format( version = tech_docs_system_version, ), ) Development #  Build #  bazel build //...\nTest #  bazel test //...\n"}]